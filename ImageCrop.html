<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Crop</title>
  <style>
    .image-container {
      position: relative;
    }

    #image-container img {
      user-drag: none;
      user-select: none;
      -moz-user-select: none;
      -webkit-user-drag: none;
      -webkit-user-select: none;
      -ms-user-select: none;
    }

    img {
      border: 1px solid rgb(150, 150, 150);
    }

    .cell {
      display: inline-block;
      padding-top: 5px;
      padding-right: 5px;
      padding-bottom: 5px;
      padding-left: 5px;
    }

    .box {
      box-sizing: border-box;
      position: absolute;
      border: 3px solid rgba(128, 0, 255, 0.61);
      pointer-events: none;
      border-style: dashed;

    }

    #dropzone {
      width: 30vw;
      height: 10vh;
      border: 2px dashed #aaa;
      margin: 20px;
      text-align: center;
      padding-top: 100px;
      font-size: 20px;
      font-weight: bold;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.0/FileSaver.min.js"></script>

</head>

<body>
  <label for="targetWInput">targetW:</label>
  <input type="number" id="targetWInput" name="targetWInput" min="1" max="5000" value="512">
  <label for="targetHInput">targetH:</label>
  <input type="number" id="targetHInput" name="targetHInput" min="1" max="5000" value="512">
  <br>
  <label for="paddingWInput">paddingW:</label>
  <input type="number" id="paddingWInput" name="paddingWInput" min="0" max="5000" value="0">
  <label for="paddingHInput">paddingH:</label>
  <input type="number" id="paddingHInput" name="paddingHInput" min="0" max="5000" value="0">
  <br>
  <button onclick="updateAll()">Apply</button>
  <br>
  <input type="file" id="folderInput" webkitdirectory>
  <h1>O R</h1>
  <div id="dropzone">Drop image here</div>

  <!-- <button onclick="saveAsJson()">SaveAsJson</button> -->
  <button onclick="clearAllImages()">Clear All Images</button>
  <button onclick="cropAllAndDownload()">Crop And Download</button>
  <div id="imageContainers"></div>

  <script>
    var draggingElement = null;
    var boxStartX, boxStartY, mouseStartX, mouseStartY;
    var divWapperBase = null;

    const boxColor = "red";

    const targetWInput = document.querySelector('#targetWInput');
    const targetHInput = document.querySelector('#targetHInput');
    const paddingWInput = document.querySelector('#paddingWInput');
    const paddingHInput = document.querySelector('#paddingHInput');
    const dropzone = document.querySelector("#dropzone");
    const folderInput = document.querySelector('#folderInput');
    const imageContainers = document.querySelector('#imageContainers');

    // ----------------------------------------Drop Box---------------------------------------------------------//
    ["dragenter", "dragover", "dragleave", "drop"].forEach(eventName => {
      dropzone.addEventListener(eventName, preventDefaults, false)
      document.body.addEventListener(eventName, preventDefaults, false)
    });

    dropzone.addEventListener("drop", handleDrop, false);

    function handleDrop(e) {
      preventDefaults(e);
      handleFiles(e.dataTransfer.files);
    }


    // ----------------------------------------Buttons---------------------------------------------------------//
    function updateAll() {
      const targetW = parseInt(targetWInput.value);
      const targetBoxHWRatio = parseInt(targetHInput.value) / targetW;
      const imgWPadding = parseInt(paddingWInput.value);
      const imgHPadding = parseInt(paddingHInput.value);
      const divWappers = getAlldivWapper();

      for (var i = 0; i < divWappers.length; i++) {
        const divWapper = divWappers[i];
        divWapper.boxLeft += imgWPadding - divWapper.imgWPadding;
        if (divWapper.boxLeft < 0) divWapper.boxLeft = 0;
        divWapper.boxTop += imgHPadding - divWapper.imgHPadding;
        if (divWapper.boxTop < 0) divWapper.boxTop = 0;

        divWapper.targetW = targetW;
        if (targetBoxHWRatio > divWapper.targetBoxHWRatio) divWapper.boxWidth = divWapper.boxWidth * divWapper.targetBoxHWRatio / targetBoxHWRatio;
        divWapper.targetBoxHWRatio = targetBoxHWRatio;
        divWapper.imgWPadding = imgWPadding;
        divWapper.imgHPadding = imgHPadding;
        renderDivWapper(divWapper);
      }
    }


    function saveAsJson() {
      const divWappers = getAlldivWapper()
      const boxsJson = divWappers.map(getDimension);
      const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(boxsJson));
      const dlAnchorElem = document.createElement("a");
      dlAnchorElem.setAttribute("href", dataStr);
      dlAnchorElem.setAttribute("download", "cropData.json");
      dlAnchorElem.click();
    }

    function clearAllImages() {
      while (imageContainers.firstChild) {
        imageContainers.removeChild(imageContainers.firstChild);
      }
    }

    folderInput.addEventListener('change', function () {
      handleFiles(folderInput.files);
    });
    // ----------------------------------------Helpers---------------------------------------------------------//
    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    function getAlldivWapper(ignoreDiscard = false) {
      retVal = [];
      var children = imageContainers.children;
      for (var i = 0; i < children.length; i++) {
        const divWapper = children[i].firstChild;
        if ((!ignoreDiscard) || (!divWapper.discard)) retVal.push(divWapper);
      }
      return retVal;
    }

    function getDimension(divWapper) {
      return {
        fileName: divWapper.fileName,
        x: parseInt((parseFloat(divWapper.lastChild.style.left) - divWapper.imgWPadding) / divWapper.scaleFactor), y: parseInt((parseFloat(divWapper.lastChild.style.top) - divWapper.imgHPadding) / divWapper.scaleFactor),
        w: parseInt(divWapper.boxWidth / divWapper.scaleFactor), h: parseInt(divWapper.boxWidth * divWapper.targetBoxHWRatio / divWapper.scaleFactor)
      };
    }

    function copyDivWapperStyle(fromDivWapper, toDivWapper) {
      if (fromDivWapper == null) return;
      toDivWapper.boxWidth = fromDivWapper.boxWidth;
      toDivWapper.targetBoxHWRatio = fromDivWapper.targetBoxHWRatio
      toDivWapper.boxLeft = fromDivWapper.boxLeft;
      toDivWapper.boxTop = fromDivWapper.boxTop;
      renderDivWapper(toDivWapper);
    }

    function createImageCell(name, imgURL, id, maxImageW, maxImageH, targetW, targetBoxHWRatio) {
      const cell = document.createElement("div");
      cell.className = "cell";
      const divWapper = document.createElement("div");
      cell.appendChild(divWapper)

      divWapper.id = "div_" + id;
      divWapper.className = "image-container";
      divWapper.style.display = "inline-block";
      divWapper.addEventListener('mousedown', (event) => { startDrag(event, divWapper) });
      divWapper.addEventListener('mousemove', (event) => { drag(event, divWapper) });
      divWapper.onwheel = (event) => { boxResize(event, divWapper) }

      divWapper.imgWPadding = parseInt(paddingWInput.value);
      divWapper.imgHPadding = parseInt(paddingHInput.value);
      divWapper.boxWidth = 50;
      divWapper.targetBoxHWRatio = targetBoxHWRatio;
      divWapper.boxLeft = 0;
      divWapper.boxTop = 0;
      divWapper.discard = false;
      divWapper.targetW = targetW;

      const image = new Image();
      divWapper.appendChild(image);

      image.id = id;
      image.src = imgURL;

      const box = document.createElement("div");
      divWapper.appendChild(box);

      box.className = "box";
      box.id = "box_" + id;

      divWapper.fileName = name;

      image.onload = () => {
        var scaleFactor = (maxImageW - 2 * divWapper.imgWPadding) / image.naturalWidth;
        if (scaleFactor > (maxImageH - 2 * divWapper.imgHPadding) / image.naturalHeight) {
          scaleFactor = (maxImageH - 2 * divWapper.imgHPadding) / image.naturalHeight;
        }
        image.width = image.naturalWidth * scaleFactor;
        image.height = image.naturalHeight * scaleFactor;
        divWapper.scaleFactor = scaleFactor;
      }

      renderDivWapper(divWapper);
      return cell;
    }

    function handleFiles(files) {
      const targetW = parseInt(targetWInput.value);
      const targetBoxHWRatio = parseInt(targetHInput.value) / targetW;
      const imgWPadding = parseInt(paddingWInput.value);
      const imgHPadding = parseInt(paddingHInput.value);

      const maxImageW = document.documentElement.clientWidth / 3;
      const maxImageH = document.documentElement.clientHeight / 3;

      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        if (file.type.match('image.*')) {
          imageContainers.appendChild(createImageCell(file.name.replace(/\.[^/.]+$/, ""), URL.createObjectURL(file), i, maxImageW, maxImageH, targetW, targetBoxHWRatio));
        }
      }
    }

    // ----------------------------------------Image Crop---------------------------------------------------------//
    function crop(divWapper) {
      const img = divWapper.firstChild;
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      canvas.width = divWapper.targetW;
      canvas.height = divWapper.targetW * divWapper.targetBoxHWRatio;

      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const dimension = getDimension(divWapper)
      ctx.drawImage(img, dimension.x, dimension.y, dimension.w, dimension.h, 0, 0, divWapper.targetW, divWapper.targetW * divWapper.targetBoxHWRatio);

      return { img: canvas.toDataURL("image/png").split(';base64,')[1], fileName: dimension.fileName };
    }

    function cropAllAndDownload() {
      const divWappers = getAlldivWapper(true);
      const newImgs = divWappers.map(crop);
      var zip = new JSZip();
      newImgs.forEach(function (imgs, index) {
        zip.file(imgs.fileName + ".png", imgs.img, { base64: true });
      });
      zip.generateAsync({ type: "blob" }).then(function (content) {
        saveAs(content, 'images.zip');
      });
    }




    // ----------------------------------------Box---------------------------------------------------------//
    function startDrag(event, divWapper) {
      event.preventDefault();
      if (event.shiftKey) {
        copyDivWapperStyle(divWapperBase, divWapper);
        return;
      } else if (event.ctrlKey) {
        divWapperBase = event.target.parentElement;
        return;
      } else if (event.altKey) {
        divWapper.discard = !divWapper.discard;
        renderDivWapper(divWapper);
        return;
      }

      const box = divWapper.lastChild;
      draggingElement = divWapper;
      boxStartX = box.offsetLeft;
      boxStartY = box.offsetTop;
      mouseStartX = event.clientX;
      mouseStartY = event.clientY;
    }

    function endDrag() {
      draggingElement = null;
    }

    function drag(event, divWapper) {
      const draggingElement_ = draggingElement;
      if (draggingElement_ == null) return;
      const img = draggingElement_.firstChild;
      const box = draggingElement_.lastChild;
      var left = boxStartX + event.clientX - mouseStartX;
      var top = boxStartY + event.clientY - mouseStartY;
      const padding = 0;
      if (left < -padding) left = -padding;
      if (top < -padding) top = -padding;
      if (left > img.clientWidth - draggingElement_.boxWidth + padding) left = img.clientWidth - draggingElement_.boxWidth + padding;
      if (top > img.clientHeight - draggingElement_.boxWidth * draggingElement_.targetBoxHWRatio + padding) top = img.clientHeight - draggingElement_.boxWidth * draggingElement_.targetBoxHWRatio + padding;
      draggingElement_.boxLeft = left;
      draggingElement_.boxTop = top;
      renderDivWapper(draggingElement_);
    }



    function renderDivWapper(divWapper) {
      const box = divWapper.lastChild;
      box.style.display = 'block';
      box.style.left = `${divWapper.boxLeft}px`;
      box.style.top = `${divWapper.boxTop}px`;
      box.style.width = `${divWapper.boxWidth}px`;
      box.style.height = `${divWapper.boxWidth * divWapper.targetBoxHWRatio}px`;
      box.style.borderColor = boxColor;
      if (divWapper.discard) { box.style.borderColor = "black"; }
      divWapper.firstChild.style.padding = `${divWapper.imgHPadding}px ${divWapper.imgWPadding}px ${divWapper.imgHPadding}px ${divWapper.imgWPadding}px`
    }

    function boxResize(event, divWapper) {
      event.preventDefault();
      const deltaSize = event.deltaY * 0.1;
      boxResize_(deltaSize, divWapper);;
    }

    function boxResize_(deltaX, divWapper) {
      const deltaY = deltaX * divWapper.targetBoxHWRatio;
      const img = divWapper.firstChild;
      const box = divWapper.lastChild

      var boxLeft = divWapper.boxLeft;
      var boxTop = divWapper.boxTop;

      const maxL = boxLeft;
      const maxR = img.clientWidth - boxLeft - divWapper.boxWidth;
      const maxT = boxTop
      const maxB = img.clientHeight - boxTop - divWapper.boxWidth * divWapper.targetBoxHWRatio;

      if (deltaX > 0 && deltaY > 0) {
        if ((maxL == 0 && maxR == 0) || (maxT == 0 && maxB == 0)) return;

        else if (maxL != 0 && maxR != 0 && (maxL * 2 < deltaX || maxR * 2 < deltaX)) return boxResize_(Math.min(maxL, maxR) * 2, divWapper);
        else if (maxT != 0 && maxB != 0 && (maxT * 2 < deltaY || maxB * 2 < deltaY)) return boxResize_(Math.min(maxT, maxB) * 2, divWapper);

        else if (maxL + maxR < deltaX) return boxResize_(maxL + maxR, divWapper);
        else if (maxT + maxB < deltaY) return boxResize_((maxT + maxB) / divWapper.targetBoxHWRatio, divWapper);

        if (maxL == 0) boxLeft += 0.5 * deltaX;
        else if (maxR == 0) boxLeft -= 0.5 * deltaX;

        if (maxT == 0) boxTop += 0.5 * deltaY;
        else if (maxB == 0) boxTop -= 0.5 * deltaY
      }

      if (divWapper.boxWidth + deltaX < 0) return boxResize_(-divWapper.boxWidth, divWapper);
      if (divWapper.boxWidth * divWapper.targetBoxHWRatio + deltaY < 0) return boxResize_(-divWapper.boxWidth, divWapper);

      divWapper.boxWidth += deltaX;

      divWapper.boxLeft = boxLeft - 0.5 * deltaX;
      divWapper.boxTop = boxTop - 0.5 * deltaY;
      renderDivWapper(divWapper);
    }

    document.addEventListener('mouseup', endDrag);

  </script>
</body>

</html>
